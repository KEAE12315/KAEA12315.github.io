<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>KEAE的编程笔记</title><link>https://keae12315.github.io/blog/</link><description>Recent content on KEAE的编程笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 06 Aug 2022 11:50:16 +0800</lastBuildDate><atom:link href="https://keae12315.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>可变与不可变究竟在说什么</title><link>https://keae12315.github.io/blog/post/%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%A9%B6%E7%AB%9F%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/</link><pubDate>Sat, 06 Aug 2022 11:50:16 +0800</pubDate><guid>https://keae12315.github.io/blog/post/%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%A9%B6%E7%AB%9F%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/</guid><description>Python中的数据类型 Numbers String List Tuple Set Dictionary python中不可变数据类型的定义为: 当该数据类型的对应变量的值发生了改变, 那么它对应的内存地址也会发生改变. 也就是说, 直接修改内存中的值, 并没有开辟新的内存. 反之就为可变类型.
不可变数据类型: numbers, string, tuple
可变数据类型: list, set, dictionary
对变量进行分析 id(): 获取对象的内存地址.
type(): 当只有一个参数的时候, 返回对象的类型. 当有三个参数的时候返回一个类对象.
==: 值比较.
is: 比较两个对象的物理id, 相当于 id(a)==id(b).
其它需要注意的 Python出于对性能的考虑, 但凡是不可变对象, 在同一个代码块中的对象, 只要是值相同的对象, 就不会重复创建, 而是直接引用已经存在的对象.
Integer object pool: This pool holds numbers of PyIntObjects which has been allocated already but not initialized (no valid value or type). Even though there is only one integer object pool.</description></item><item><title>MySQL入门</title><link>https://keae12315.github.io/blog/post/mysql%E5%85%A5%E9%97%A8/</link><pubDate>Sat, 06 Aug 2022 11:49:50 +0800</pubDate><guid>https://keae12315.github.io/blog/post/mysql%E5%85%A5%E9%97%A8/</guid><description>基本概念 数据库(Database, DB): 将大量数据保存起来, 通过计算机加工而成的可以进行高效访问的数据集合. 数据库管理系统(Database Management System, DBMS): 管理数据库的计算机系统. 表(Table): 包含数据库中所有数据的数据库对象, 定义为列的集合. 与电子表格相似, 数据在表中式按行和列的格式组织排列的. 列(Column): 又称字段(Field), 存储某种类型的信息. 每列只能指定一种数据类型. 行: 又称记录或元组, 一组相关的数据. 主键: 记录的唯一标识, 通常指定一个字段担任, 但也可以通过复合不同字段构成唯一标识, 此时称为复合键. 外键: 创建 数据库: CREATE DATABASE dbname; 表: CREATE TABLE table_name; 字段: 创建/新增字段时, 也要对数据类型和值的限制进行设置. 数据类型 数值 TINYINT SMALLINT MEDIUMINT INT / INTEGER BIGINT FLOAT DOUBLE DECIMAL 日期 DATE TIME YEAR DATETIME TIMESTAMP 字符 CHAR VARCHAR TINYBLOB TINYTEXT BLOB TEXT MEDIUMBLOB MEDIUMTEXT LONGBLOB LONGTEXT 特殊值 NULL</description></item><item><title>继承，重载，多态，泛型与封装</title><link>https://keae12315.github.io/blog/post/%E7%BB%A7%E6%89%BF%E9%87%8D%E8%BD%BD%E5%A4%9A%E6%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%B0%81%E8%A3%85/</link><pubDate>Sat, 06 Aug 2022 11:48:44 +0800</pubDate><guid>https://keae12315.github.io/blog/post/%E7%BB%A7%E6%89%BF%E9%87%8D%E8%BD%BD%E5%A4%9A%E6%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%B0%81%E8%A3%85/</guid><description>Encapsulation
可见性private Inheritance Polymorphism 类, 抽象类/方法, Interface
Inheritance 单继承 多继承 多子类继承 多(父类)继承, Java不支持, 容易造成致命方块. 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。
实际上, 在保证无歧义的情况下, 继承是树状结构. 但现实生活中存在网状结构, Java用接口的方式实现了多父类继承的概念, 但是要求你一定要单独给出实现, 避免了歧义.
如何取得子类和父类:
super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 this关键字：指向自己的引用。 Override 外壳不变，核心重写
Overload 就是函数或者方法有相同的名称，但是参数列表不相同的情形
Generics 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。
泛型只在编译阶段有效。在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。
泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。
注：JDK 1.8 以后，接口里可以有静态方法和方法体了。
注：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为&amp;quot;默认方法&amp;rdquo;，默认方法使用 default 关键字修饰。更多内容可参考 Java 8 默认方法。
注：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。更多内容可参考 Java 9 私有接口方法。</description></item><item><title>多线程漫谈</title><link>https://keae12315.github.io/blog/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%BC%AB%E8%B0%88/</link><pubDate>Sat, 06 Aug 2022 11:48:28 +0800</pubDate><guid>https://keae12315.github.io/blog/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%BC%AB%E8%B0%88/</guid><description>Process Thread
多任务 多进程 Multithreading
The state of the thread
New：新创建的线程，尚未执行； Runnable：运行中的线程，正在执行run()方法的Java代码； Blocked：运行中的线程，因为某些操作被阻塞而挂起； Waiting：运行中的线程，因为某些操作在等待中； Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待； Terminated：线程已终止，因为run()方法执行完毕. 线程操作
run join interrupt: isInterrupted setDaemon synchronized: 多线程竞争 wait和notify(All): 多线程协调(当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。) 线程同步 保证一段代码的原子性就是通过加锁和解锁实现的. Java程序使用synchronized关键字对一个对象进行加锁.
注意加锁对象必须是同一个实例
JVM规范定义了几种原子操作：
基本类型（long和double除外）赋值，例如：int n = m； 引用类型赋值，例如：Listlist = anotherList。 如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）
线程死锁 形成死锁必须同时满足互斥、请求保持、不可抢占、循环等待。死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。
线程顺序访问资源，是破坏了循环等待条件，属于死锁预防的策略。
线程间通信 线程控制：挂起、停止和恢复</description></item><item><title>设计模式</title><link>https://keae12315.github.io/blog/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 06 Aug 2022 11:48:04 +0800</pubDate><guid>https://keae12315.github.io/blog/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>创建模式 工厂方法：Factory Method 抽象工厂：Abstract Factory 建造者：Builder 原型：Prototype 单例：Singleton 结构型模式 适配器 桥接 组合 装饰器 外观 享元 代理 行为模式 责任链 命令 解释器 迭代器 中介 备忘录 观察者 状态 策略 模板方法 访问者 参考资料
https://refactoringguru.cn/design-patterns/catalog
https://www.liaoxuefeng.com/wiki/1252599548343744/1281319090782242</description></item><item><title>数据结构漫谈</title><link>https://keae12315.github.io/blog/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BC%AB%E8%B0%88/</link><pubDate>Sat, 06 Aug 2022 11:47:19 +0800</pubDate><guid>https://keae12315.github.io/blog/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BC%AB%E8%B0%88/</guid><description>一个苹果的表示 别误会，这并不是牛顿的苹果；而是从一开始，人们如何表示苹果的数量为1个。对物品的数量描述，催生了数字的出现。一个苹果的概念天然不可分割，尽管我们可以把它劈成两半，但是也许用劈开的苹果来说更合适，因为它离一个苹果中苹果所表示的概念&amp;ndash;那个圆圆的，皮红叶绿的苹果&amp;ndash;已经有所区别。对于这种不可分割的概念，数量的表示只有整数。但很快，对一堆苹果来说，它就可以被分成几分了（先假设能整分好了）。这种概念催生了
基本数据 整数
浮点数
有点特殊的字符与字符串
Data Structures Arrays Linked Lists Stacks Queues Hash Tables 新的问题, 假设我们需要存一下学生的身份证号和名字, 该怎么用数组来做呢? 身份证是唯一的, 每个人都不一样, 但名字有可能相同. 当然可以用一个二维数组, 但问题是, 唯一的下标索引对应唯一的身份证号, 如果能用身份证号做索引就好了. 但数组在内存中是连续的, 身份证号却不一定连续, 做下标会让空间浪费, 而且我们也很难确定该要多少内存空间.
现在再回忆一下, 因为身份证号唯一, 我们希望能直接通过身份证号代替下标索引找到内存地址存取姓名, 但数组本身的设计却很难完成这一点. 抽象一下就是, 一组数据, 有唯一的关键词key, 对应相应的value. 那么, 如何有效地存取一组key-vaule键值对?
注意, 这里有四个关键词:
key-value键值对 一组 存 取 现在, 我们有一个key, 有一个对应的value. 我们想通过key直接定位到存储位置. 如果能有一个函数f(), 对唯一的key有唯一的f(k)值, 那么我们把这个唯一的f(k)值作为存储地址, 那么下次无论是查询还是存储, 只要知道k, 再通过f(k)计算出存储地址, 不就可以了吗. 确实如此, 我们已经基本搞清了原理, 但还有一些小问题需要解决.
如果f(k)的值域是无穷 在有限域上, 基本概念
key value Hash function 散列表 Collision Java中的Hash Table 在Java中, 用Map表示键值对的数据结构, 但Map并不指定用什么方式存储键值对.</description></item><item><title>排序算法</title><link>https://keae12315.github.io/blog/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 06 Aug 2022 11:45:28 +0800</pubDate><guid>https://keae12315.github.io/blog/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid><description>排序算法是《数据结构与算法》中最基本的算法之一.
排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存. 常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等. 用一张图概括：
排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 冒泡 O(n^2) O(n) O(n^2) O(1) In-place 稳定 选择 O(n^2) O(n^2) O(n^2) O(1) In-place 不稳定 插入 O(n^2) O(n) O(n^2) O(1) In-place 稳定 希尔 O(n log n) O(n log2 n) O(n log2 n) O(1) In-place 不稳定 归并 O(n log n) O(n log n) O(n log n) O(n) Out-place 稳定 快速 O(n log n) O(n log n) O(n^2) O(log n) In-place 不稳定 堆 O(n log n) O(n log n) O(n log n) O(1) In-place 不稳定 计数 O(n+k) O(n+k) O(n+k) O(k) Out-place 稳定 桶 O(n+k) O(n+k) O(n^2) O(n+k) Out-place 稳定 基数 O(n*k) O(n*k) O(n*k) O(n+k) Out-place 稳定 名词解释：</description></item><item><title>Git常用</title><link>https://keae12315.github.io/blog/post/git%E5%B8%B8%E7%94%A8/</link><pubDate>Fri, 05 Aug 2022 16:50:39 +0800</pubDate><guid>https://keae12315.github.io/blog/post/git%E5%B8%B8%E7%94%A8/</guid><description>git checkout &amp;lt;branch&amp;gt;</description></item><item><title>Ubuntu22.04安装后配置</title><link>https://keae12315.github.io/blog/post/ubuntu%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/</link><pubDate>Fri, 05 Aug 2022 03:19:27 +0800</pubDate><guid>https://keae12315.github.io/blog/post/ubuntu%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/</guid><description>查看系统版本 # 操作系统内核信息 uname －a # 操作系统版本信息 cat /proc/version # 操作系统发行版信息 cat /etc/issue # cpu相关信息 cat /proc/cpuinfo # 版本多少位 getconf LONG_BIT lsb_release -a 设置Git 本地Git用户邮箱设置 # 查看git配置信息 git config --list # 查看用户名 git config user.name # 查看邮箱 git config user.email # 设置全局用户名 git config --global user.name &amp;quot;&amp;quot; # 设置全局邮箱 git config --global user.email &amp;quot;&amp;quot; 生成SSH key ssh-keygen -t ed25519 -C &amp;quot;&amp;quot; 一路回车, 默认生成到~/.ssh目录下.
将后缀为.pub文件的内容添加到GitHub账户里.
换源 Ubuntu 的软件源配置文件是 /etc/apt/sources.list
备份配置文件
sudo cp /etc/apt/sources.</description></item><item><title>WSL2使用v2ray代理</title><link>https://keae12315.github.io/blog/post/wsl2%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/</link><pubDate>Thu, 04 Aug 2022 12:25:49 +0800</pubDate><guid>https://keae12315.github.io/blog/post/wsl2%E4%BD%BF%E7%94%A8v2ray%E4%BB%A3%E7%90%86/</guid><description>主机V2Ray设置 允许局域网连接 获取监听端口 对我而言, 有用的端口是局域网socks:10810
WSL2设置 配置环境变量 修改.bashrc文件, 添加以下内容(记得source .bashrc)
# v2ray proxy export windows_host=`cat /etc/resolv.conf|grep nameserver|awk '{print $2}'` export ALL_PROXY=socks5://$windows_host:10810 export HTTP_PROXY=$ALL_PROXY export http_proxy=$ALL_PROXY export HTTPS_PROXY=$ALL_PROXY export https_proxy=$ALL_PROXY 测试连接情况 curl -vv google.com 参考资料
WSL2中使用windows的代理
记录一次WSL2的网络代理配置</description></item><item><title>Hugo入门</title><link>https://keae12315.github.io/blog/post/hugo%E5%85%A5%E9%97%A8/</link><pubDate>Thu, 04 Aug 2022 00:58:00 +0800</pubDate><guid>https://keae12315.github.io/blog/post/hugo%E5%85%A5%E9%97%A8/</guid><description>安装与配置 主题 安装主题
git submodule add git@github.com:adityatelange/hugo-PaperMod.git themes/hugo-PaperMod 使用主题: 在配置文件config.yaml中使用如下配置项
theme: hugo-PaperMod 基本操作 生成新文章
hugo new post/&amp;lt;filename&amp;gt;.md 为了简化操作, 在.bashrc文件里设置h函数
h(){ hugo new post/$1.md } 部署到GitHub Page 生成token 我自己笔记的源码和github.io的仓库分开, 为了能够获取仓库的读写权限, 需要生成personal token. 并在源码仓库里设置(token的名字要与workflow配置文件里一致).
设置workflow文件 生成.github/workflows/gh-pages.yml文件, 内容如下.
name: GitHub Pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .</description></item></channel></rss>