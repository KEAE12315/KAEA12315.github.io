<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>可变与不可变究竟在说什么 | KEAE的编程笔记</title><meta name=keywords content="Python"><meta name=description content="Python中的数据类型  Numbers String List Tuple Set Dictionary  python中不可变数据类型的定义为: 当该数据类型的对应变量的值发生了改变, 那么它对应的内存地址也会发生改变. 也就是说, 直接修改内存中的值, 并没有开辟新的内存. 反之就为可变类型.
不可变数据类型: numbers, string, tuple
可变数据类型: list, set, dictionary
对变量进行分析 id(): 获取对象的内存地址.
type(): 当只有一个参数的时候, 返回对象的类型. 当有三个参数的时候返回一个类对象.
==: 值比较.
is: 比较两个对象的物理id, 相当于 id(a)==id(b).
其它需要注意的 Python出于对性能的考虑, 但凡是不可变对象, 在同一个代码块中的对象, 只要是值相同的对象, 就不会重复创建, 而是直接引用已经存在的对象.
Integer object pool: This pool holds numbers of PyIntObjects which has been allocated already but not initialized (no valid value or type). Even though there is only one integer object pool."><meta name=author content="keae"><link rel=canonical href=https://keae12315.github.io/blog/post/%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%A9%B6%E7%AB%9F%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.abc7c82c3d415a6df50430738d1cbcc4c76fea558bc5a0c830d3babf78167a35.css integrity="sha256-q8fILD1BWm31BDBzjRy8xMdv6lWLxaDIMNO6v3gWejU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://keae12315.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://keae12315.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://keae12315.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://keae12315.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://keae12315.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="可变与不可变究竟在说什么"><meta property="og:description" content="Python中的数据类型  Numbers String List Tuple Set Dictionary  python中不可变数据类型的定义为: 当该数据类型的对应变量的值发生了改变, 那么它对应的内存地址也会发生改变. 也就是说, 直接修改内存中的值, 并没有开辟新的内存. 反之就为可变类型.
不可变数据类型: numbers, string, tuple
可变数据类型: list, set, dictionary
对变量进行分析 id(): 获取对象的内存地址.
type(): 当只有一个参数的时候, 返回对象的类型. 当有三个参数的时候返回一个类对象.
==: 值比较.
is: 比较两个对象的物理id, 相当于 id(a)==id(b).
其它需要注意的 Python出于对性能的考虑, 但凡是不可变对象, 在同一个代码块中的对象, 只要是值相同的对象, 就不会重复创建, 而是直接引用已经存在的对象.
Integer object pool: This pool holds numbers of PyIntObjects which has been allocated already but not initialized (no valid value or type). Even though there is only one integer object pool."><meta property="og:type" content="article"><meta property="og:url" content="https://keae12315.github.io/blog/post/%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%A9%B6%E7%AB%9F%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-08-06T11:50:16+08:00"><meta property="article:modified_time" content="2022-08-06T11:50:16+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="可变与不可变究竟在说什么"><meta name=twitter:description content="Python中的数据类型  Numbers String List Tuple Set Dictionary  python中不可变数据类型的定义为: 当该数据类型的对应变量的值发生了改变, 那么它对应的内存地址也会发生改变. 也就是说, 直接修改内存中的值, 并没有开辟新的内存. 反之就为可变类型.
不可变数据类型: numbers, string, tuple
可变数据类型: list, set, dictionary
对变量进行分析 id(): 获取对象的内存地址.
type(): 当只有一个参数的时候, 返回对象的类型. 当有三个参数的时候返回一个类对象.
==: 值比较.
is: 比较两个对象的物理id, 相当于 id(a)==id(b).
其它需要注意的 Python出于对性能的考虑, 但凡是不可变对象, 在同一个代码块中的对象, 只要是值相同的对象, 就不会重复创建, 而是直接引用已经存在的对象.
Integer object pool: This pool holds numbers of PyIntObjects which has been allocated already but not initialized (no valid value or type). Even though there is only one integer object pool."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"可变与不可变究竟在说什么","item":"https://keae12315.github.io/blog/post/%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%A9%B6%E7%AB%9F%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"可变与不可变究竟在说什么","name":"可变与不可变究竟在说什么","description":"Python中的数据类型  Numbers String List Tuple Set Dictionary  python中不可变数据类型的定义为: 当该数据类型的对应变量的值发生了改变, 那么它对应的内存地址也会发生改变. 也就是说, 直接修改内存中的值, 并没有开辟新的内存. 反之就为可变类型.\n不可变数据类型: numbers, string, tuple\n可变数据类型: list, set, dictionary\n对变量进行分析 id(): 获取对象的内存地址.\ntype(): 当只有一个参数的时候, 返回对象的类型. 当有三个参数的时候返回一个类对象.\n==: 值比较.\nis: 比较两个对象的物理id, 相当于 id(a)==id(b).\n其它需要注意的 Python出于对性能的考虑, 但凡是不可变对象, 在同一个代码块中的对象, 只要是值相同的对象, 就不会重复创建, 而是直接引用已经存在的对象.\nInteger object pool: This pool holds numbers of PyIntObjects which has been allocated already but not initialized (no valid value or type). Even though there is only one integer object pool.","keywords":["Python"],"articleBody":"Python中的数据类型  Numbers String List Tuple Set Dictionary  python中不可变数据类型的定义为: 当该数据类型的对应变量的值发生了改变, 那么它对应的内存地址也会发生改变. 也就是说, 直接修改内存中的值, 并没有开辟新的内存. 反之就为可变类型.\n不可变数据类型: numbers, string, tuple\n可变数据类型: list, set, dictionary\n对变量进行分析 id(): 获取对象的内存地址.\ntype(): 当只有一个参数的时候, 返回对象的类型. 当有三个参数的时候返回一个类对象.\n==: 值比较.\nis: 比较两个对象的物理id, 相当于 id(a)==id(b).\n其它需要注意的 Python出于对性能的考虑, 但凡是不可变对象, 在同一个代码块中的对象, 只要是值相同的对象, 就不会重复创建, 而是直接引用已经存在的对象.\nInteger object pool: This pool holds numbers of PyIntObjects which has been allocated already but not initialized (no valid value or type). Even though there is only one integer object pool. This pool is divided into 2 parts, small integers and big integers. Big integers are exactly the case mentioned above, where PyIntObject is used as a container for the integer and even integers having the same value have their own PyIntObject.\nString Interning in Python: The string interning in Python is a mechanism of storing only one copy of a string value in the memory. If there are a few string variables whose values are the same, they will be interned by Python implicitly and refer to the same object in the memory.\n x, y = 100, 40000  id(2 * x + y) == id(300 + x) True  2 * x + y, 300 + x (40200, 400) The two expressions 2 * x + y and 300 + x don’t have overlapping lifetimes. That means that Python can calculate the left hand side, take its id, and then free the integer before it calculates the right hand side. When CPython frees an integer it puts it on a list of freed integers and then re-uses it for a different integer the next time it needs one. So your ids match even when the result of the calculations are very different:\n 参考资料\n https://zhuanlan.zhihu.com/p/68577036及评论 https://stackoverflow.com/questions/6101379/what-happens-behind-the-scenes-when-python-adds-small-ints https://davejingtian.org/2014/12/11/python-internals-integer-object-pool-pyintobject/ https://medium.com/techtofreedom/string-interning-in-python-a-hidden-gem-that-makes-your-code-faster-9be71c7a5f3e   ","wordCount":"282","inLanguage":"en","datePublished":"2022-08-06T11:50:16+08:00","dateModified":"2022-08-06T11:50:16+08:00","author":{"@type":"Person","name":"keae"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://keae12315.github.io/blog/post/%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%A9%B6%E7%AB%9F%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/"},"publisher":{"@type":"Organization","name":"KEAE的编程笔记","logo":{"@type":"ImageObject","url":"https://keae12315.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=https://keae12315.github.io/blog/ accesskey=h title="KEAE的编程笔记 (Alt + H)">KEAE的编程笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>可变与不可变究竟在说什么</h1><div class=post-meta><span title="2022-08-06 11:50:16 +0800 +0800">August 6, 2022</span>&nbsp;·&nbsp;keae</div></header><div class=post-content><h2 id=python中的数据类型>Python中的数据类型<a hidden class=anchor aria-hidden=true href=#python中的数据类型>#</a></h2><ul><li>Numbers</li><li>String</li><li>List</li><li>Tuple</li><li>Set</li><li>Dictionary</li></ul><p><strong>python中不可变数据类型的定义为</strong>: 当该数据类型的对应变量的值发生了改变, 那么它对应的内存地址也会发生改变. 也就是说, 直接修改内存中的值, 并没有开辟新的内存. 反之就为可变类型.</p><p>不可变数据类型: numbers, string, tuple<br>可变数据类型: list, set, dictionary</p><h2 id=对变量进行分析>对变量进行分析<a hidden class=anchor aria-hidden=true href=#对变量进行分析>#</a></h2><p>id(): 获取对象的内存地址.<br>type(): 当只有一个参数的时候, 返回对象的类型. 当有三个参数的时候返回一个类对象.<br>==: 值比较.<br>is: 比较两个对象的物理id, 相当于 id(a)==id(b).</p><h2 id=其它需要注意的>其它需要注意的<a hidden class=anchor aria-hidden=true href=#其它需要注意的>#</a></h2><p>Python出于对性能的考虑, 但凡是不可变对象, 在同一个代码块中的对象, 只要是值相同的对象, 就不会重复创建, 而是直接引用已经存在的对象.</p><p><strong>Integer object pool</strong>: This pool holds numbers of PyIntObjects which has been allocated already but not initialized (no valid value or type). Even though there is only one integer object pool. This pool is divided into 2 parts, small integers and big integers. Big integers are exactly the case mentioned above, where PyIntObject is used as a container for the integer and even integers having the same value have their own PyIntObject.</p><p><strong>String Interning in Python</strong>: The string interning in Python is a mechanism of storing only one copy of a string value in the memory. If there are a few string variables whose values are the same, they will be interned by Python implicitly and refer to the same object in the memory.</p><pre><code>&gt;&gt;&gt; x, y = 100, 40000
&gt;&gt;&gt; id(2 * x + y) == id(300 + x)
True
&gt;&gt;&gt; 2 * x + y, 300 + x
(40200, 400)
</code></pre><p>The two expressions 2 * x + y and 300 + x don&rsquo;t have overlapping lifetimes. That means that Python can calculate the left hand side, take its id, and then free the integer before it calculates the right hand side. When CPython frees an integer it puts it on a list of freed integers and then re-uses it for a different integer the next time it needs one. So your ids match even when the result of the calculations are very different:</p><blockquote><p>参考资料</p><ul><li><a href=https://zhuanlan.zhihu.com/p/68577036>https://zhuanlan.zhihu.com/p/68577036</a>及评论</li><li><a href=https://stackoverflow.com/questions/6101379/what-happens-behind-the-scenes-when-python-adds-small-ints>https://stackoverflow.com/questions/6101379/what-happens-behind-the-scenes-when-python-adds-small-ints</a></li><li><strong><a href=https://davejingtian.org/2014/12/11/python-internals-integer-object-pool-pyintobject/>https://davejingtian.org/2014/12/11/python-internals-integer-object-pool-pyintobject/</a></strong></li><li><a href=https://medium.com/techtofreedom/string-interning-in-python-a-hidden-gem-that-makes-your-code-faster-9be71c7a5f3e>https://medium.com/techtofreedom/string-interning-in-python-a-hidden-gem-that-makes-your-code-faster-9be71c7a5f3e</a></li></ul></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://keae12315.github.io/blog/tags/python/>Python</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://keae12315.github.io/blog/>KEAE的编程笔记</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z" /></svg></a><script>let menu=document.getElementById('menu')
if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>