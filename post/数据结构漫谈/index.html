<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>数据结构漫谈 | KEAE的编程笔记</title><meta name=keywords content="Data Structures and Algorithms"><meta name=description content="一个苹果的表示 别误会，这并不是牛顿的苹果；而是从一开始，人们如何表示苹果的数量为1个。对物品的数量描述，催生了数字的出现。一个苹果的概念天然不可分割，尽管我们可以把它劈成两半，但是也许用劈开的苹果来说更合适，因为它离一个苹果中苹果所表示的概念&ndash;那个圆圆的，皮红叶绿的苹果&ndash;已经有所区别。对于这种不可分割的概念，数量的表示只有整数。但很快，对一堆苹果来说，它就可以被分成几分了（先假设能整分好了）。这种概念催生了
基本数据 整数
浮点数
有点特殊的字符与字符串
Data Structures Arrays Linked Lists Stacks Queues Hash Tables 新的问题, 假设我们需要存一下学生的身份证号和名字, 该怎么用数组来做呢? 身份证是唯一的, 每个人都不一样, 但名字有可能相同. 当然可以用一个二维数组, 但问题是, 唯一的下标索引对应唯一的身份证号, 如果能用身份证号做索引就好了. 但数组在内存中是连续的, 身份证号却不一定连续, 做下标会让空间浪费, 而且我们也很难确定该要多少内存空间.
现在再回忆一下, 因为身份证号唯一, 我们希望能直接通过身份证号代替下标索引找到内存地址存取姓名, 但数组本身的设计却很难完成这一点. 抽象一下就是, 一组数据, 有唯一的关键词key, 对应相应的value. 那么, 如何有效地存取一组key-vaule键值对?
注意, 这里有四个关键词:
 key-value键值对 一组 存 取  现在, 我们有一个key, 有一个对应的value. 我们想通过key直接定位到存储位置. 如果能有一个函数f(), 对唯一的key有唯一的f(k)值, 那么我们把这个唯一的f(k)值作为存储地址, 那么下次无论是查询还是存储, 只要知道k, 再通过f(k)计算出存储地址, 不就可以了吗. 确实如此, 我们已经基本搞清了原理, 但还有一些小问题需要解决.
 如果f(k)的值域是无穷 在有限域上,  基本概念
 key value Hash function 散列表 Collision  Java中的Hash Table 在Java中, 用Map表示键值对的数据结构, 但Map并不指定用什么方式存储键值对."><meta name=author content="keae"><link rel=canonical href=https://keae12315.github.io/blog/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BC%AB%E8%B0%88/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.abc7c82c3d415a6df50430738d1cbcc4c76fea558bc5a0c830d3babf78167a35.css integrity="sha256-q8fILD1BWm31BDBzjRy8xMdv6lWLxaDIMNO6v3gWejU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://keae12315.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://keae12315.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://keae12315.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://keae12315.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://keae12315.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="数据结构漫谈"><meta property="og:description" content="一个苹果的表示 别误会，这并不是牛顿的苹果；而是从一开始，人们如何表示苹果的数量为1个。对物品的数量描述，催生了数字的出现。一个苹果的概念天然不可分割，尽管我们可以把它劈成两半，但是也许用劈开的苹果来说更合适，因为它离一个苹果中苹果所表示的概念&ndash;那个圆圆的，皮红叶绿的苹果&ndash;已经有所区别。对于这种不可分割的概念，数量的表示只有整数。但很快，对一堆苹果来说，它就可以被分成几分了（先假设能整分好了）。这种概念催生了
基本数据 整数
浮点数
有点特殊的字符与字符串
Data Structures Arrays Linked Lists Stacks Queues Hash Tables 新的问题, 假设我们需要存一下学生的身份证号和名字, 该怎么用数组来做呢? 身份证是唯一的, 每个人都不一样, 但名字有可能相同. 当然可以用一个二维数组, 但问题是, 唯一的下标索引对应唯一的身份证号, 如果能用身份证号做索引就好了. 但数组在内存中是连续的, 身份证号却不一定连续, 做下标会让空间浪费, 而且我们也很难确定该要多少内存空间.
现在再回忆一下, 因为身份证号唯一, 我们希望能直接通过身份证号代替下标索引找到内存地址存取姓名, 但数组本身的设计却很难完成这一点. 抽象一下就是, 一组数据, 有唯一的关键词key, 对应相应的value. 那么, 如何有效地存取一组key-vaule键值对?
注意, 这里有四个关键词:
 key-value键值对 一组 存 取  现在, 我们有一个key, 有一个对应的value. 我们想通过key直接定位到存储位置. 如果能有一个函数f(), 对唯一的key有唯一的f(k)值, 那么我们把这个唯一的f(k)值作为存储地址, 那么下次无论是查询还是存储, 只要知道k, 再通过f(k)计算出存储地址, 不就可以了吗. 确实如此, 我们已经基本搞清了原理, 但还有一些小问题需要解决.
 如果f(k)的值域是无穷 在有限域上,  基本概念
 key value Hash function 散列表 Collision  Java中的Hash Table 在Java中, 用Map表示键值对的数据结构, 但Map并不指定用什么方式存储键值对."><meta property="og:type" content="article"><meta property="og:url" content="https://keae12315.github.io/blog/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BC%AB%E8%B0%88/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-08-06T11:47:19+08:00"><meta property="article:modified_time" content="2022-08-06T11:47:19+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="数据结构漫谈"><meta name=twitter:description content="一个苹果的表示 别误会，这并不是牛顿的苹果；而是从一开始，人们如何表示苹果的数量为1个。对物品的数量描述，催生了数字的出现。一个苹果的概念天然不可分割，尽管我们可以把它劈成两半，但是也许用劈开的苹果来说更合适，因为它离一个苹果中苹果所表示的概念&ndash;那个圆圆的，皮红叶绿的苹果&ndash;已经有所区别。对于这种不可分割的概念，数量的表示只有整数。但很快，对一堆苹果来说，它就可以被分成几分了（先假设能整分好了）。这种概念催生了
基本数据 整数
浮点数
有点特殊的字符与字符串
Data Structures Arrays Linked Lists Stacks Queues Hash Tables 新的问题, 假设我们需要存一下学生的身份证号和名字, 该怎么用数组来做呢? 身份证是唯一的, 每个人都不一样, 但名字有可能相同. 当然可以用一个二维数组, 但问题是, 唯一的下标索引对应唯一的身份证号, 如果能用身份证号做索引就好了. 但数组在内存中是连续的, 身份证号却不一定连续, 做下标会让空间浪费, 而且我们也很难确定该要多少内存空间.
现在再回忆一下, 因为身份证号唯一, 我们希望能直接通过身份证号代替下标索引找到内存地址存取姓名, 但数组本身的设计却很难完成这一点. 抽象一下就是, 一组数据, 有唯一的关键词key, 对应相应的value. 那么, 如何有效地存取一组key-vaule键值对?
注意, 这里有四个关键词:
 key-value键值对 一组 存 取  现在, 我们有一个key, 有一个对应的value. 我们想通过key直接定位到存储位置. 如果能有一个函数f(), 对唯一的key有唯一的f(k)值, 那么我们把这个唯一的f(k)值作为存储地址, 那么下次无论是查询还是存储, 只要知道k, 再通过f(k)计算出存储地址, 不就可以了吗. 确实如此, 我们已经基本搞清了原理, 但还有一些小问题需要解决.
 如果f(k)的值域是无穷 在有限域上,  基本概念
 key value Hash function 散列表 Collision  Java中的Hash Table 在Java中, 用Map表示键值对的数据结构, 但Map并不指定用什么方式存储键值对."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"数据结构漫谈","item":"https://keae12315.github.io/blog/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BC%AB%E8%B0%88/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"数据结构漫谈","name":"数据结构漫谈","description":"一个苹果的表示 别误会，这并不是牛顿的苹果；而是从一开始，人们如何表示苹果的数量为1个。对物品的数量描述，催生了数字的出现。一个苹果的概念天然不可分割，尽管我们可以把它劈成两半，但是也许用劈开的苹果来说更合适，因为它离一个苹果中苹果所表示的概念\u0026ndash;那个圆圆的，皮红叶绿的苹果\u0026ndash;已经有所区别。对于这种不可分割的概念，数量的表示只有整数。但很快，对一堆苹果来说，它就可以被分成几分了（先假设能整分好了）。这种概念催生了\n基本数据 整数\n浮点数\n有点特殊的字符与字符串\nData Structures Arrays Linked Lists Stacks Queues Hash Tables 新的问题, 假设我们需要存一下学生的身份证号和名字, 该怎么用数组来做呢? 身份证是唯一的, 每个人都不一样, 但名字有可能相同. 当然可以用一个二维数组, 但问题是, 唯一的下标索引对应唯一的身份证号, 如果能用身份证号做索引就好了. 但数组在内存中是连续的, 身份证号却不一定连续, 做下标会让空间浪费, 而且我们也很难确定该要多少内存空间.\n现在再回忆一下, 因为身份证号唯一, 我们希望能直接通过身份证号代替下标索引找到内存地址存取姓名, 但数组本身的设计却很难完成这一点. 抽象一下就是, 一组数据, 有唯一的关键词key, 对应相应的value. 那么, 如何有效地存取一组key-vaule键值对?\n注意, 这里有四个关键词:\n key-value键值对 一组 存 取  现在, 我们有一个key, 有一个对应的value. 我们想通过key直接定位到存储位置. 如果能有一个函数f(), 对唯一的key有唯一的f(k)值, 那么我们把这个唯一的f(k)值作为存储地址, 那么下次无论是查询还是存储, 只要知道k, 再通过f(k)计算出存储地址, 不就可以了吗. 确实如此, 我们已经基本搞清了原理, 但还有一些小问题需要解决.\n 如果f(k)的值域是无穷 在有限域上,  基本概念\n key value Hash function 散列表 Collision  Java中的Hash Table 在Java中, 用Map表示键值对的数据结构, 但Map并不指定用什么方式存储键值对.","keywords":["Data Structures and Algorithms"],"articleBody":"一个苹果的表示 别误会，这并不是牛顿的苹果；而是从一开始，人们如何表示苹果的数量为1个。对物品的数量描述，催生了数字的出现。一个苹果的概念天然不可分割，尽管我们可以把它劈成两半，但是也许用劈开的苹果来说更合适，因为它离一个苹果中苹果所表示的概念–那个圆圆的，皮红叶绿的苹果–已经有所区别。对于这种不可分割的概念，数量的表示只有整数。但很快，对一堆苹果来说，它就可以被分成几分了（先假设能整分好了）。这种概念催生了\n基本数据 整数\n浮点数\n有点特殊的字符与字符串\nData Structures Arrays Linked Lists Stacks Queues Hash Tables 新的问题, 假设我们需要存一下学生的身份证号和名字, 该怎么用数组来做呢? 身份证是唯一的, 每个人都不一样, 但名字有可能相同. 当然可以用一个二维数组, 但问题是, 唯一的下标索引对应唯一的身份证号, 如果能用身份证号做索引就好了. 但数组在内存中是连续的, 身份证号却不一定连续, 做下标会让空间浪费, 而且我们也很难确定该要多少内存空间.\n现在再回忆一下, 因为身份证号唯一, 我们希望能直接通过身份证号代替下标索引找到内存地址存取姓名, 但数组本身的设计却很难完成这一点. 抽象一下就是, 一组数据, 有唯一的关键词key, 对应相应的value. 那么, 如何有效地存取一组key-vaule键值对?\n注意, 这里有四个关键词:\n key-value键值对 一组 存 取  现在, 我们有一个key, 有一个对应的value. 我们想通过key直接定位到存储位置. 如果能有一个函数f(), 对唯一的key有唯一的f(k)值, 那么我们把这个唯一的f(k)值作为存储地址, 那么下次无论是查询还是存储, 只要知道k, 再通过f(k)计算出存储地址, 不就可以了吗. 确实如此, 我们已经基本搞清了原理, 但还有一些小问题需要解决.\n 如果f(k)的值域是无穷 在有限域上,  基本概念\n key value Hash function 散列表 Collision  Java中的Hash Table 在Java中, 用Map表示键值对的数据结构, 但Map并不指定用什么方式存储键值对. 实际上, Map只是一个接口. 其中HashMap以hash table的方式实现对键值对的存储, 是Map接口的一个实现类.\nTrees Tree traversal\n Depth-first search  Pre-order, NLR Post-order, LRN In-order, LNR   Breadth-first search  Graphs  参考资料\nhttps://segmentfault.com/a/1190000015796727\nhttps://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8\nhttps://segmentfault.com/a/1190000015796727 https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap\nhttps://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86#:~:text=%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%A3%A1%EF%BC%8C%E6%A0%91,%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E3%80%82\n ","wordCount":"98","inLanguage":"en","datePublished":"2022-08-06T11:47:19+08:00","dateModified":"2022-08-06T11:47:19+08:00","author":{"@type":"Person","name":"keae"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://keae12315.github.io/blog/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%BC%AB%E8%B0%88/"},"publisher":{"@type":"Organization","name":"KEAE的编程笔记","logo":{"@type":"ImageObject","url":"https://keae12315.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=https://keae12315.github.io/blog/ accesskey=h title="KEAE的编程笔记 (Alt + H)">KEAE的编程笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>数据结构漫谈</h1><div class=post-meta><span title="2022-08-06 11:47:19 +0800 +0800">August 6, 2022</span>&nbsp;·&nbsp;keae</div></header><div class=post-content><h2 id=一个苹果的表示>一个苹果的表示<a hidden class=anchor aria-hidden=true href=#一个苹果的表示>#</a></h2><p>别误会，这并不是牛顿的苹果；而是从一开始，人们如何表示苹果的数量为1个。对物品的数量描述，催生了数字的出现。一个苹果的概念天然不可分割，尽管我们可以把它劈成两半，但是也许用劈开的苹果来说更合适，因为它离一个苹果中苹果所表示的概念&ndash;那个圆圆的，皮红叶绿的苹果&ndash;已经有所区别。对于这种不可分割的概念，数量的表示只有整数。但很快，对一堆苹果来说，它就可以被分成几分了（先假设能整分好了）。这种概念催生了</p><h2 id=基本数据>基本数据<a hidden class=anchor aria-hidden=true href=#基本数据>#</a></h2><p>整数<br>浮点数<br>有点特殊的字符与字符串</p><h2 id=data-structures>Data Structures<a hidden class=anchor aria-hidden=true href=#data-structures>#</a></h2><h3 id=arrays>Arrays<a hidden class=anchor aria-hidden=true href=#arrays>#</a></h3><h3 id=linked-lists>Linked Lists<a hidden class=anchor aria-hidden=true href=#linked-lists>#</a></h3><h3 id=stacks>Stacks<a hidden class=anchor aria-hidden=true href=#stacks>#</a></h3><h3 id=queues>Queues<a hidden class=anchor aria-hidden=true href=#queues>#</a></h3><h3 id=hash-tables>Hash Tables<a hidden class=anchor aria-hidden=true href=#hash-tables>#</a></h3><p>新的问题, 假设我们需要存一下学生的身份证号和名字, 该怎么用数组来做呢? 身份证是唯一的, 每个人都不一样, 但名字有可能相同. 当然可以用一个二维数组, 但问题是, 唯一的下标索引对应唯一的身份证号, 如果能用身份证号做索引就好了. 但数组在内存中是连续的, 身份证号却不一定连续, 做下标会让空间浪费, 而且我们也很难确定该要多少内存空间.</p><p>现在再回忆一下, 因为身份证号唯一, 我们希望能直接通过身份证号代替下标索引找到内存地址存取姓名, 但数组本身的设计却很难完成这一点. 抽象一下就是, 一组数据, 有唯一的关键词key, 对应相应的value. 那么, 如何有效地存取一组key-vaule键值对?</p><p>注意, 这里有四个关键词:</p><ul><li>key-value键值对</li><li>一组</li><li>存</li><li>取</li></ul><p>现在, 我们有一个key, 有一个对应的value. 我们想通过key直接定位到存储位置. 如果能有一个函数f(), 对唯一的key有唯一的f(k)值, 那么我们把这个唯一的f(k)值作为存储地址, 那么下次无论是查询还是存储, 只要知道k, 再通过f(k)计算出存储地址, 不就可以了吗. 确实如此, 我们已经基本搞清了原理, 但还有一些小问题需要解决.</p><ul><li>如果f(k)的值域是无穷</li><li>在有限域上,</li></ul><p>基本概念</p><ul><li>key</li><li>value</li><li>Hash function</li><li>散列表</li><li>Collision</li></ul><h4 id=java中的hash-table>Java中的Hash Table<a hidden class=anchor aria-hidden=true href=#java中的hash-table>#</a></h4><p>在Java中, 用Map表示键值对的数据结构, 但Map并不指定用什么方式存储键值对. 实际上, Map只是一个接口. 其中HashMap以hash table的方式实现对键值对的存储, 是Map接口的一个实现类.</p><h3 id=trees>Trees<a hidden class=anchor aria-hidden=true href=#trees>#</a></h3><p>Tree traversal</p><ul><li>Depth-first search<ul><li>Pre-order, NLR</li><li>Post-order, LRN</li><li>In-order, LNR</li></ul></li><li>Breadth-first search</li></ul><h3 id=graphs>Graphs<a hidden class=anchor aria-hidden=true href=#graphs>#</a></h3><blockquote><p>参考资料<br><a href=https://segmentfault.com/a/1190000015796727>https://segmentfault.com/a/1190000015796727</a><br><a href=https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8>https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8</a><br><a href=https://segmentfault.com/a/1190000015796727>https://segmentfault.com/a/1190000015796727</a>
<a href=https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap>https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap</a><br><a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86#:~:text=%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%A3%A1%EF%BC%8C%E6%A0%91,%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E3%80%82">https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86#:~:text=%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%A3%A1%EF%BC%8C%E6%A0%91,%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E3%80%82</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://keae12315.github.io/blog/tags/data-structures-and-algorithms/>Data Structures and Algorithms</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://keae12315.github.io/blog/>KEAE的编程笔记</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z" /></svg></a><script>let menu=document.getElementById('menu')
if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>