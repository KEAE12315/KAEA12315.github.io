(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{279:function(v,_,t){"use strict";t.r(_);var i=t(13),e=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("Process\nThread")]),v._v(" "),_("p",[v._v("多任务\n多进程\nMultithreading")]),v._v(" "),_("p",[v._v("The state of the thread")]),v._v(" "),_("ul",[_("li",[v._v("New：新创建的线程，尚未执行；")]),v._v(" "),_("li",[v._v("Runnable：运行中的线程，正在执行run()方法的Java代码；")]),v._v(" "),_("li",[v._v("Blocked：运行中的线程，因为某些操作被阻塞而挂起；")]),v._v(" "),_("li",[v._v("Waiting：运行中的线程，因为某些操作在等待中；")]),v._v(" "),_("li",[v._v("Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；")]),v._v(" "),_("li",[v._v("Terminated：线程已终止，因为run()方法执行完毕.")])]),v._v(" "),_("p",[v._v("线程操作")]),v._v(" "),_("ul",[_("li",[v._v("run")]),v._v(" "),_("li",[v._v("join")]),v._v(" "),_("li",[v._v("interrupt: isInterrupted")]),v._v(" "),_("li",[v._v("setDaemon")]),v._v(" "),_("li",[v._v("synchronized: 多线程竞争")]),v._v(" "),_("li",[v._v("wait和notify(All): 多线程协调(当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。)")])]),v._v(" "),_("h2",{attrs:{id:"线程同步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程同步"}},[v._v("#")]),v._v(" 线程同步")]),v._v(" "),_("p",[v._v("保证一段代码的原子性就是通过加锁和解锁实现的. Java程序使用synchronized关键字对一个对象进行加锁.")]),v._v(" "),_("p",[v._v("注意加锁对象必须是同一个实例")]),v._v(" "),_("p",[v._v("JVM规范定义了几种原子操作：")]),v._v(" "),_("ul",[_("li",[v._v("基本类型（long和double除外）赋值，例如：int n = m；")]),v._v(" "),_("li",[v._v("引用类型赋值，例如：List"),_("String",[v._v(" list = anotherList。")])],1)]),v._v(" "),_("p",[v._v("如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）")]),v._v(" "),_("h2",{attrs:{id:"线程死锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程死锁"}},[v._v("#")]),v._v(" 线程死锁")]),v._v(" "),_("p",[v._v("形成死锁必须同时满足互斥、请求保持、不可抢占、循环等待。死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。")]),v._v(" "),_("p",[v._v("线程顺序访问资源，是破坏了循环等待条件，属于死锁预防的策略。")]),v._v(" "),_("p",[v._v("线程间通信\n线程控制：挂起、停止和恢复")])])}),[],!1,null,null,null);_.default=e.exports}}]);