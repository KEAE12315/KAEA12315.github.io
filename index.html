<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.106.0"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>KEAE的编程笔记</title><meta name=keywords content="Blog,Hugo,PaperMod"><meta name=description content="记录下来吧"><meta name=author content="plw"><link rel=canonical href=https://keae12315.github.io/blog/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/blog/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><link rel=icon href=https://keae12315.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://keae12315.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://keae12315.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://keae12315.github.io/blog/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://keae12315.github.io/blog/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://keae12315.github.io/blog/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="KEAE的编程笔记"><meta property="og:description" content="记录下来吧"><meta property="og:type" content="website"><meta property="og:url" content="https://keae12315.github.io/blog/"><meta property="og:image" content="https://keae12315.github.io/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="KEAE的编程笔记"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://keae12315.github.io/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="KEAE的编程笔记"><meta name=twitter:description content="记录下来吧"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"KEAE的编程笔记","url":"https://keae12315.github.io/blog/","description":"记录下来吧","thumbnailUrl":"https://keae12315.github.io/blog/%3Clink%20/%20abs%20url%3E","sameAs":["https://stackoverflow.com","https://github.com/KEAE12315"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://keae12315.github.io/blog/ accesskey=h title="KEAE的编程笔记 (Alt + H)"><img src=https://keae12315.github.io/apple-touch-icon.png alt aria-label=logo height=35>KEAE的编程笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://keae12315.github.io/blog/categories/ title=categories><span>categories</span></a></li><li><a href=https://keae12315.github.io/blog/tags/ title=tags><span>tags</span></a></li><li><a href=https://github.com/KEAE12315 title=GitHub><span>GitHub</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>Hi there 👋</h1></header><div class=entry-content>Welcome to my blog</div><footer class=entry-footer><div class=social-icons><a href=https://stackoverflow.com target=_blank rel="noopener noreferrer me" title=Stackoverflow><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.913 16.041v6.848h17.599v-6.848M7.16 18.696h8.925M7.65 13.937l8.675 1.8M9.214 9.124l8.058 3.758M12.086 4.65l6.849 5.66M15.774 1.111l5.313 7.162"/></svg></a><a href=https://github.com/KEAE12315 target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></footer></article><article class=post-entry><header class=entry-header><h2>一文讲懂函数中的参数问题(更新中</h2></header><div class=entry-content><p>语言之外 对于频繁使用的代码块, 我们一般将其封装成函数. 函数有时需要参数, 例如简单的两数求和函数, 总是需要给出相加的两数.
为了表示函数需要参数, 我们在函数定义时即定义了形参. 在实际调用时, 再传入具体的参数, 称为实参.
但是这里还有几个问题需要解决:
实参如何与形参对应? 如果需要默认值呢? 为了防止乱传参数导致崩溃, 如何做一些限制? 下面, 我们一一讲解参数有关的问题.
参数限制 函数调用时, 如果传入不合法的参数, 程序也许能运行, 但可能无法得到结果. 例如, 两数相加函数如果传入了字符'5’和'6’, 由于+运算符重载, 会返回字符串'56’. 跟我们想要的结果11大相径庭. 当然, 更多的时候是直接报错.
类型限制 对于静态语言如Java, 由于编译时即进行数据类型检查, 因此一般在定义函数时, 就必须指定参数的类型.
对于动态语言如Python, 需要自己手动加入判断部分. 不过自Python3.5开始，PEP484引入了类型注解.
注意, Python的类型注解仅仅提供了编辑器进行类型检测的机会, 但是对程序的运行不会产生任何影响!
其它限制 有些时候, 尽管类型正确, 但参数只在指定范围内有效, 又或者有别的限制条件. 这时, 需要在函数内部书写对应的参数检查代码. 如果不符合要求就执行对应的操作, 如抛出异常. 这里通常是判断语句如if, switch等.
断言是一种在许多语言中常见的关键词, 它判断后面语句的布尔值, true则继续运行, false则抛出异常. 也可以用于参数检查.
位置参数 默认参数 Python中默认参数的坑
可变参数 关键词参数 参数的组合使用 模块运行的参数 参考资料
动态语言和静态语言的区别
函数的参数
Python类型注解，你需要知道的都在这里了</p></div><footer class=entry-footer><span title='2022-08-17 01:06:18 +0800 +0800'>August 17, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;68 words&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to 一文讲懂函数中的参数问题(更新中" href=https://keae12315.github.io/blog/post/%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0/></a></article><article class=post-entry><header class=entry-header><h2>可变与不可变究竟在说什么</h2></header><div class=entry-content><p>Python中的数据类型 Numbers String List Tuple Set Dictionary 首先必须明确在python中所有的变量都是一个引用, 引用保存的是对象的地址.
所谓可变对象是指, 对象的内容是可变的.
而不可变对象, 由于无法改变对象的内容, 当修改值时, 会开辟新的内存空间储存新值, 并将变量的对象引用改过去.
不可变数据类型: numbers, string, tuple
可变数据类型: list, set, dictionary
如何判断可变还是不可变 当改变变量值时, 对象内存地址改变的就为不可变类型. 以下是一些工具:
id(): 获取对象的内存地址. type(): 当只有一个参数的时候, 返回对象的类型. 当有三个参数的时候返回一个类对象. ==: 值比较. is: 比较两个对象的物理id, 相当于 id(a)==id(b). 作为函数和类的参数 python中向函数传递参数只能是引用传递, 表示把它的地址都传进去了. 所以向函数中传递可变对象时, 会影响全局中的这个变量值. 同样的, 向类传递可变对象也是如此.
其实这个特性也不能说是一个弊端, 利用这一点可以进行一些很方便的操作, 比如两个线程同时操作一个队列, 我们不用设置一个global队列, 只要将队列这个可变对象传入类之中, 修改就会自动同步.
>>> def myfunc(l): ... l.append(1) ... print(l) ... >>> l = [1, 2, 3] >>> myfunc(l) [1, 2, 3, 1] >>> l [1, 2, 3, 1] >>> def myfunc(a): ....</p></div><footer class=entry-footer><span title='2022-08-06 11:50:16 +0800 +0800'>August 6, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;400 words&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to 可变与不可变究竟在说什么" href=https://keae12315.github.io/blog/post/%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%A9%B6%E7%AB%9F%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/></a></article><article class=post-entry><header class=entry-header><h2>下载</h2></header><div class=entry-content><p>a</p></div><footer class=entry-footer><span title='2022-11-19 14:26:44 +0800 +0800'>November 19, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;word&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to 下载" href=https://keae12315.github.io/blog/post/skills/%E4%B8%8B%E8%BD%BD/></a></article><article class=post-entry><header class=entry-header><h2>使用frp进行内网穿透</h2></header><div class=entry-content><p>官方链接：https://github.com/fatedier/frp/releases
请按照需要选择合适的版本, 可以直接下载也可以拷贝链接用命令行.
安装 以0.45版本, linux64位为例.
使用wget下载: wget https://github.com/fatedier/frp/releases/download/v0.45.0/frp_0.45.0_linux_amd64.tar.gz 解压frp压缩包 tar -zxvf frp_0.45.0_linux_amd64.tar.gz 移动至/usr/local mkdir /usr/local/frp mv frp_0.45.0_linux_amd64/* /usr/local/frp/ ./frpc -c ./frpc.ini 文件说明
frps.ini: 服务端配置文件 frps: 服务端软件 frpc.ini: 客户端配置文件 frpc: 客户端软件 配置systemctl控制 vim新建文件并写入配置内容 vim /usr/lib/systemd/system/frp.service 写入以下内容，注意上文移动放置的路径和此处有关。这里是启动的服务端。 [Unit] Description=The nginx HTTP and reverse proxy server After=network.target remote-fs.target nss-lookup.target [Service] Type=simple ExecStart=/usr/local/frp/frps -c /usr/local/frp/frps.ini KillSignal=SIGQUIT TimeoutStopSec=5 KillMode=process PrivateTmp=true StandardOutput=syslog StandardError=inherit [Install] WantedBy=multi-user.target 重新加载服务的配置文件 systemctl daemon-reload 现在就可以用 systemctl套装来控制frp了
# 启动 systemctl start frp # 停止 systemctl stop frp # 重启 systemctl restart frp # 状态查看 systemctl status frp # 设置开机自启 systemctl enable frp # 关闭开机自启 systemctl disable frp sudo journalctl -u frp sudo vim /usr/local/frp/frps....</p></div><footer class=entry-footer><span title='2022-11-03 11:09:41 +0800 +0800'>November 3, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;128 words&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to 使用frp进行内网穿透" href=https://keae12315.github.io/blog/post/frp/></a></article><article class=post-entry><header class=entry-header><h2>Python用前需知</h2></header><div class=entry-content><p>pip pip常用命令 pip install pip list pip换源 临时使用 -i 命令指定下载源
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package 命令行全局切换 要求pip版本>=10.0.0
python -m pip install --upgrade pip pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 如果升级pip时默认源的网络连接较差，可以利用刚才的-i临时指定下载源
python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pip 国内镜像库列表 https://pypi.tuna.tsinghua.edu.cn/simple https://mirrors.aliyun.com/pypi/simple/ https://pypi.mirrors.ustc.edu.cn/simple http://pypi.douban.com/simple/ http://mirrors.aliyun.com/pypi/simple/ 虚拟环境 参考资料:
PyPI 镜像使用帮助</p></div><footer class=entry-footer><span title='2022-09-29 13:54:09 +0800 +0800'>September 29, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;47 words&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to Python用前需知" href=https://keae12315.github.io/blog/post/python%E7%94%A8%E5%89%8D%E9%9C%80%E7%9F%A5/></a></article><article class=post-entry><header class=entry-header><h2>单例模式的五种实现方式及优缺点</h2></header><div class=entry-content><p>转载
当我们需要使得某个类只能有一个实例时，可以使用单例模式。
单例模式（Singleton Design Pattern）保证一个类只能有一个实例，并提供一个全局访问点。
单例模式的实现需要三个必要的条件：
单例类的构造函数必须是私有的，这样才能将类的创建权控制在类的内部，从而使得类的外部不能创建类的实例。 单例类通过一个私有的静态变量来存储其唯一实例。 单例类通过提供一个公开的静态方法，使得外部使用者可以访问类的唯一实例。 注意： 因为单例类的构造函数是私有的，所以单例类不能被继承。 另外，实现单例类时，还需要考虑三个问题：
创建单例对象时，是否线程安全。 单例对象的创建，是否延时加载。 获取单例对象时，是否需要加锁（锁会导致低性能）。 下面介绍五种实现单例模式的方式。 饿汉式 public class Singleton { private static final Singleton instance = new Singleton(); private Singleton () {} public static Singleton getInstance() { return instance; } } 懒汉式 public class Singleton { private static final Singleton instance; private Singleton () {} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 双重检测 public class Singleton { private static Singleton instance; private Singleton () {} public static Singleton getInstance() { if (instance == null) { synchronized(Singleton....</p></div><footer class=entry-footer><span title='2022-08-26 16:34:19 +0800 +0800'>August 26, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;268 words&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to 单例模式的五种实现方式及优缺点" href=https://keae12315.github.io/blog/post/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/></a></article><article class=post-entry><header class=entry-header><h2>Java中的final</h2></header><div class=entry-content><p>修饰类 不可被继承
修饰方法 不可被覆盖
特别地, 对于private修饰的父类方法, 由于子类接触不到, 可以写同名同参的方法. 此时相当于在子类中重新定义了新的方法.
private方法会被隐式地指定为final
修饰变量 final修饰变量时, 变量内容只能被赋值一次, 赋值后不再改变.
对基本数据类型: 值在初始化后不再改变. 对引用类型: 值即地址, 所以只能引用该对象. 但仅限地址不改变, 所以对象的内容可以发生变化. final变量的编译器优化 public class Test { public static void main(String[] args) { String a = "helloworld"; final String b = "hello"; String c = "hello"; String x = b + "world"; String y = c + "world"; System.out.println(a == x); System.out.println(a == y); } } >>> true >>> false 修饰参数时的情况 参考文献...</p></div><footer class=entry-footer><span title='2022-08-26 12:04:49 +0800 +0800'>August 26, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;72 words&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to Java中的final" href=https://keae12315.github.io/blog/post/java%E4%B8%AD%E7%9A%84final/></a></article><article class=post-entry><header class=entry-header><h2>怎样才算相等？</h2></header><div class=entry-content><p>计算机如何存储数据 不同维度上的相等 地址相等 值相等 不同语言中的相等比较 Java ==: 地址相等
equals():
hashcode():</p></div><footer class=entry-footer><span title='2022-08-26 11:32:25 +0800 +0800'>August 26, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;10 words&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to 怎样才算相等？" href=https://keae12315.github.io/blog/post/%E6%80%8E%E6%A0%B7%E6%89%8D%E7%AE%97%E7%9B%B8%E7%AD%89/></a></article><article class=post-entry><header class=entry-header><h2>Python是强类型语言？谁说的！</h2></header><div class=entry-content><p>在网上看到一个结论: Python是解释型的强类型动态语言. 感到违背直觉, 查询之后确有出入, 随便补齐了相关知识, 特此记录.
编程语言分类 编译型or解释型 编译型 指通过编译器（compiler）将源代码编译为机器码（machine code）后运行的语言，例如C、C++.
解释型 指由解释器（interpreter）直接执行，不需要编译成机器语言，例如PHP、JavaScript.
强类型or弱类型 强类型 是一种强制类型定义的语言，即一旦某一个变量被定义类型，如果不经强制转换，那么它永远就是该数据类型。
弱类型 是一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过现行强制转换。
动态型or静态型 动态型 运行时才进行数据类型检查 即在变量赋值时，才确定变量的数据类型，不用事先给变量指定数据类型 。
静态型 静态类型语言与动态类型语言刚好相反，需要事先给变量进行数据类型定义 。
这种分类为什么不行了? 我们应当关注什么 参考资料
谁告诉的你们Python是强类型语言！站出来，保证不打你！
python是解释型的强类型动态语言
虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩</p></div><footer class=entry-footer><span title='2022-08-17 11:41:08 +0800 +0800'>August 17, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;32 words&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to Python是强类型语言？谁说的！" href=https://keae12315.github.io/blog/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB/></a></article><article class=post-entry><header class=entry-header><h2>地道的Python循环</h2></header><div class=entry-content><p>在循环语法方面，Python 选择了 for 和 while 这两个经典的关键字来表达循环。绝大多数情况下，我们的循环需求都可以用 for in 来满足，while 相比之下则用的更少些。
Python 的 for 循环只有 for in 这一种结构，而结构里的前半部分 - 赋值给 item - 没有太多花样可玩。所以后半部分的 可迭代对象 是我们唯一能够大做文章的东西。而以 enumerate() 函数为代表的“修饰函数”，刚好提供了一种思路：通过修饰可迭代对象来优化循环本身。
使用函数修饰被迭代对象来优化循环 内置模块 itertools 是一个包含很多面向可迭代对象的工具函数集。 Python 官方文档是学习的首选，里面有非常详细的模块相关资料。下面给出一些常用的函数。
enumerate(iterable)：返回元素和下标 product(A, B)：返回A, B的笛卡儿积 islice(seq, start, end, step)：循环内隔行处理 takewhile(predicate, iterable)：替代 break 语句 zip(A, B)：按顺序同时迭代A，B 按职责拆解循环体内复杂代码块 写循环时，我们很容易往循环体塞入越来越多的代码，包括过滤掉无效元素、预处理数据、打印日志等等，甚至一些原本不属于同一抽象的内容，导致各部分功能耦合。
这样一个复杂循环体在面对新需求时难以解耦复用。考虑使用生成器函数解耦循环体。
参考资料:
Python 工匠：编写地道循环的两个建议</p></div><footer class=entry-footer><span title='2022-08-08 01:05:13 +0800 +0800'>August 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;52 words&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to 地道的Python循环" href=https://keae12315.github.io/blog/post/%E5%9C%B0%E9%81%93%E7%9A%84python%E5%BE%AA%E7%8E%AF/></a></article><article class=post-entry><header class=entry-header><h2>如何理解Python中的装饰器</h2></header><div class=entry-content><p>装饰器来自 Decorator 的直译，就是装点、提供一些额外的点缀。 在 Python 中的装饰器则是提供了一些额外的功能，可以让你的函数在不改变代码的情况下拥有新的功能。
首先，Python中的函数也是一个对象，这意味着函数：
能在函数中定义一个函数 能作为参数传递 能作为返回值 def decorator(func): def wrapper(*args, **kwargs): print('123') return func(*args, **kwargs) return wrapper def say_hello(): print('同学你好') say_hello_super = decorator(say_hello) say_hello_super() 123 同学你好 在以上这段代码中，我们将一个函数 say_hello 作为参数传入函数 decorator，返回一个 wrapper 函数并赋值到 say_hello_super，此时执行 say_hello_super 相当于执行 wrapper 函数。当我们执行 wrapper 函数时会先打印 123 再执行先前传入的 func 参数也就是 say_hello 函数。
注意 wrapper 的 *args 与 **kwargs 参数，这是必须的， *args 表示所有的位置参数，**kwargs 表示所有的关键字参数。之后再将其传到 func函数中， 这样保证了能完全传递所有参数。
在这里，decorator 这个函数就是一个装饰器，功能是在执行被装饰的函数之前打印 123。
在 python 中， 有一种语法糖可以代替 say_hello_super = decorator(say_hello) 这一步的操作，以上的代码可以改写成。...</p></div><footer class=entry-footer><span title='2022-08-08 01:01:02 +0800 +0800'>August 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;199 words&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to 如何理解Python中的装饰器" href=https://keae12315.github.io/blog/post/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/></a></article><article class=post-entry><header class=entry-header><h2>Python文件处理的常用方法</h2></header><div class=entry-content><p>遍历文件或目录 我们常常需要对数据集文件夹中的数据进行遍历，Python内置的 os 模块有很多有用的方法能被用来列出目录内容和过滤结果。
常用函数介绍 os.listdir(path) 返回一个list，其中包含path参数所指目录的文件和子目录的名称
os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]]) top – 返回值，为一个三元组(root,dirs,files)。 root 所指的是当前正在遍历的这个文件夹的本身的地址 dirs 是一个 list ，内容是该文件夹中所有的目录的名字(不包括子目录) files 同样是 list , 内容是该文件夹中所有的文件(不包括子目录) topdown –可选，控制遍历是从上到下，还是反过来。 为True优先遍历上层目录，否则优先遍历最底层目录(默认为True)。 onerror – 可选，需要一个 callable 对象，当 walk 需要异常时，会调用。 followlinks – 可选，如果为 True，则会遍历目录下的快捷方式(linux 下是软连接 symbolic link )实际所指的目录(默认关闭)，如果为 False，则优先遍历 top 的子目录。 示例代码:
for root,dirs,files in os.walk(mypath): print(root) for dr in dirs: print(dr) for name in files: if name.endswith(".txt"): print(os.path.join(root, name)) 排序问题
需要注意的是os.walk使用os.listdir，两者返回的列表都是任意顺序的，如果想要获得排序，考虑使用sort。例如：
# 如果要按排序顺序递归目录，则就地修改dirs for root, dirs, files in os....</p></div><footer class=entry-footer><span title='2022-08-08 00:56:36 +0800 +0800'>August 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;106 words&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to Python文件处理的常用方法" href=https://keae12315.github.io/blog/post/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/></a></article><article class=post-entry><header class=entry-header><h2>Python程序计时</h2></header><div class=entry-content><p>python的time内置模块是一个与时间相关的内置模块，存在不同的模块可以用于程序计时.
使用time.time() 很多人喜欢用time.time()获取当前时间的时间戳，利用程序前后两个时间戳的差值计算程序的运行时间，如下：
import time T1 = time.time() #______假设下面是程序部分______ for i in range(100*100): pass T2 = time.time() print('程序运行时间:%s毫秒' % ((T2 - T1)*1000)) # 程序运行时间:0.0毫秒 不要以为你的处理器很厉害，就忽视了一个问题，一万次遍历，时间为0.0毫秒？
下面解决上面的质疑，
使用time.clock() Python time clock() 函数以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。
这个需要注意，在不同的系统上含义不同。在UNIX系统上，它返回的是”进程时间”，它是用秒表示的浮点数（时间戳）。而在WINDOWS中，第一次调用，返回的是进程运行的实际时间。而第二次之后的调用是自第一次调用以后到现在的运行时间。（实际上是以WIN32上QueryPerformanceCounter()为基础，它比毫秒表示更为精确）
使用time.clock()更改后的程序查看一下：
import platform print('系统:',platform.system()) import time T1 = time.clock() #______假设下面是程序部分______ for i in range(100*100): pass T2 =time.clock() print('程序运行时间:%s毫秒' % ((T2 - T1)*1000)) # 程序运行时间:0.27023641716203606毫秒 使用time.perf_counter() 返回性能计数器的值（以微秒为单位,1秒=1000毫秒；1毫秒=1000微秒）作为浮点数，即具有最高可用分辨率的时钟，以测量短持续时间。它包括在睡眠期间和系统范围内流逝的时间。返回值的参考点未定义，因此只有连续调用结果之间的差异有效。
1秒 = 1000毫秒
1毫秒 = 1000微秒
1微秒 = 1000纳秒
1纳秒 = 1000皮秒...</p></div><footer class=entry-footer><span title='2022-08-08 00:51:32 +0800 +0800'>August 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;133 words&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to Python程序计时" href=https://keae12315.github.io/blog/post/python%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%97%B6/></a></article><article class=post-entry><header class=entry-header><h2>使用搜索引擎的技巧</h2></header><div class=entry-content><p>学会使用搜索运算符 关于算术运算符的几个小技巧其实并不新鲜，很多是和搜索引擎本身一起诞生的，甚至已经成为了各个搜索引擎的一种通用标准。 不过鉴于仍然有许多人不知道这些搜索运算符，或者没有概念它们具体能做什么，所以我们先来讲一讲这些最基本的知识。
双引号""：完全匹配。结果中必须出现与搜索文本完全相同的内容。 短横-：排除。 加号+：包含搜索。 ~ 进行同义词搜索。 site：在某个网站内搜索。 filetype：搜索对应类型的文件。 link 搜索网页中含有某链接的结果，比如搜索：link:http://baidu.com，则结果为包含百度这个链接的页面。
intitle 搜索标题内包含关键词的结果。
inurl 搜索网站地址中包含关键词的结果。
related 搜索相关网站。
index of 可以突破网站入口下载。
如何进行学术搜索 综述类关键词 overview survey review</p></div><footer class=entry-footer><span title='2022-08-08 00:50:01 +0800 +0800'>August 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;26 words&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to 使用搜索引擎的技巧" href=https://keae12315.github.io/blog/post/%E4%BD%BF%E7%94%A8%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%8A%80%E5%B7%A7/></a></article><article class=post-entry><header class=entry-header><h2>VS Code远程连接</h2></header><div class=entry-content><p>微软针对VS Code的远程开发推出了三个插件，包括:
Remote-SSH: SSH 连接虚拟/实体Linux主机; Remote-Container: 连接容器; Remote-WSL: 连接WSL(也就是Linux子系统). 重点服务使用Windows但具有Linux开发需求的用户. 使用Remote-SSH连接实验室服务器 这里是微软关于SSH连接的官方文档
安装Remote-SSH插件 在Extension侧边栏搜索Remote-ssh并安装
修改ssh配置文件 在VS Code里crtl+shift+p，打开命令行输入open ssh, 选择第一个选项Remote-SSH: Open SSH Configuration File..., 可直接打开C:\Users\&lt;user>\.ssh\config文件. 也可以直接编辑该文件. 如果没有这个文件夹，在管理可选功能里添加 OpenSSH 客户端.
在config文件中写入以下内容
Host Labserve #填写别名 HostName 1.1.1.1 #填写实验室服务器IP/host User user #填写ssh用户名 Port port #填写端口号. 可缺省该配置, 默认为22. 添加ssh公钥 远程ssh连接Linux服务器时，需要借助ssh公钥登录.
客户端生成ssh公钥 在cmd中输入ssh-keygen，一路回车键，完成后在$HOME/.ssh/目录下可以发现两个文件: id_rsa.pub和id_rsa，分别是客户端的公钥和私钥.
上传ssh公钥
登录远程服务器，创建.ssh目录和authorized_keys文件
mkdir ~/.ssh/ cd ~/.ssh/ vim authorized_keys 修改服务器端ssh配置
vim /etc/ssh/sshd_config RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile $h/.ssh/authorized_keys 保存并退出vim.
重启ssh服务 service ssh restart 通过CONNECTION侧边栏进行连接 此时，已经可以在CONNECTION侧边栏看见服务器的别名，点击进行连接....</p></div><footer class=entry-footer><span title='2022-08-08 00:39:12 +0800 +0800'>August 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;100 words&nbsp;·&nbsp;plw</footer><a class=entry-link aria-label="post link to VS Code远程连接" href=https://keae12315.github.io/blog/post/vscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://keae12315.github.io/blog/page/2/>Next »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://keae12315.github.io/blog/>KEAE的编程笔记</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>