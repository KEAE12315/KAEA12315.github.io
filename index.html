<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.68.3"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>KEAE的编程笔记</title><meta name=description content><meta name=author content="keae"><link rel=canonical href=https://keae12315.github.io/blog/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.abc7c82c3d415a6df50430738d1cbcc4c76fea558bc5a0c830d3babf78167a35.css integrity="sha256-q8fILD1BWm31BDBzjRy8xMdv6lWLxaDIMNO6v3gWejU=" rel="preload stylesheet" as=style><link rel=icon href=https://keae12315.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://keae12315.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://keae12315.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://keae12315.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://keae12315.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://keae12315.github.io/blog/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="KEAE的编程笔记"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://keae12315.github.io/blog/"><meta name=twitter:card content="summary"><meta name=twitter:title content="KEAE的编程笔记"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"KEAE的编程笔记","url":"https://keae12315.github.io/blog/","description":"","thumbnailUrl":"https://keae12315.github.io/blog/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=https://keae12315.github.io/blog/ accesskey=h title="KEAE的编程笔记 (Alt + H)">KEAE的编程笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=first-entry><header class=entry-header><h2>可变与不可变究竟在说什么</h2></header><div class=entry-content><p>Python中的数据类型 Numbers String List Tuple Set Dictionary python中不可变数据类型的定义为: 当该数据类型的对应变量的值发生了改变, 那么它对应的内存地址也会发生改变. 也就是说, 直接修改内存中的值, 并没有开辟新的内存. 反之就为可变类型.
不可变数据类型: numbers, string, tuple
可变数据类型: list, set, dictionary
对变量进行分析 id(): 获取对象的内存地址.
type(): 当只有一个参数的时候, 返回对象的类型. 当有三个参数的时候返回一个类对象.
==: 值比较.
is: 比较两个对象的物理id, 相当于 id(a)==id(b).
其它需要注意的 Python出于对性能的考虑, 但凡是不可变对象, 在同一个代码块中的对象, 只要是值相同的对象, 就不会重复创建, 而是直接引用已经存在的对象.
Integer object pool: This pool holds numbers of PyIntObjects which has been allocated already but not initialized (no valid value or type). Even though there is only one integer object pool....</p></div><footer class=entry-footer><span title="2022-08-06 11:50:16 +0800 +0800">August 6, 2022</span>&nbsp;·&nbsp;keae</footer><a class=entry-link aria-label="post link to 可变与不可变究竟在说什么" href=https://keae12315.github.io/blog/post/%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%A9%B6%E7%AB%9F%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/></a></article><article class=post-entry><header class=entry-header><h2>地道的Python循环</h2></header><div class=entry-content><p>在循环语法方面，Python 选择了 for 和 while 这两个经典的关键字来表达循环。绝大多数情况下，我们的循环需求都可以用 for in 来满足，while 相比之下则用的更少些。
Python 的 for 循环只有 for in 这一种结构，而结构里的前半部分 - 赋值给 item - 没有太多花样可玩。所以后半部分的 可迭代对象 是我们唯一能够大做文章的东西。而以 enumerate() 函数为代表的“修饰函数”，刚好提供了一种思路：通过修饰可迭代对象来优化循环本身。
使用函数修饰被迭代对象来优化循环 内置模块 itertools 是一个包含很多面向可迭代对象的工具函数集。 Python 官方文档是学习的首选，里面有非常详细的模块相关资料。下面给出一些常用的函数。
enumerate(iterable)：返回元素和下标 product(A, B)：返回A, B的笛卡儿积 islice(seq, start, end, step)：循环内隔行处理 takewhile(predicate, iterable)：替代 break 语句 zip(A, B)：按顺序同时迭代A，B 按职责拆解循环体内复杂代码块 写循环时，我们很容易往循环体塞入越来越多的代码，包括过滤掉无效元素、预处理数据、打印日志等等，甚至一些原本不属于同一抽象的内容，导致各部分功能耦合。
这样一个复杂循环体在面对新需求时难以解耦复用。考虑使用生成器函数解耦循环体。
参考资料:
Python工匠：编写地道循环的两个建议</p></div><footer class=entry-footer><span title="2022-08-08 01:05:13 +0800 +0800">August 8, 2022</span>&nbsp;·&nbsp;keae</footer><a class=entry-link aria-label="post link to 地道的Python循环" href=https://keae12315.github.io/blog/post/%E5%9C%B0%E9%81%93%E7%9A%84python%E5%BE%AA%E7%8E%AF/></a></article><article class=post-entry><header class=entry-header><h2>如何理解Python中的装饰器</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title="2022-08-08 01:01:02 +0800 +0800">August 8, 2022</span>&nbsp;·&nbsp;keae</footer><a class=entry-link aria-label="post link to 如何理解Python中的装饰器" href=https://keae12315.github.io/blog/post/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/></a></article><article class=post-entry><header class=entry-header><h2>Python文件处理的常用方法</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title="2022-08-08 00:56:36 +0800 +0800">August 8, 2022</span>&nbsp;·&nbsp;keae</footer><a class=entry-link aria-label="post link to Python文件处理的常用方法" href=https://keae12315.github.io/blog/post/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/></a></article><article class=post-entry><header class=entry-header><h2>Python程序计时</h2></header><div class=entry-content><p>python的time内置模块是一个与时间相关的内置模块，存在不同的模块可以用于程序计时.
使用time.time() 很多人喜欢用time.time()获取当前时间的时间戳，利用程序前后两个时间戳的差值计算程序的运行时间，如下：
import time T1 = time.time() #______假设下面是程序部分______ for i in range(100*100): pass T2 = time.time() print('程序运行时间:%s毫秒' % ((T2 - T1)*1000)) # 程序运行时间:0.0毫秒 不要以为你的处理器很厉害，就忽视了一个问题，一万次遍历，时间为0.0毫秒？
下面解决上面的质疑，
使用time.clock() Python time clock() 函数以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。
这个需要注意，在不同的系统上含义不同。在UNIX系统上，它返回的是”进程时间”，它是用秒表示的浮点数（时间戳）。而在WINDOWS中，第一次调用，返回的是进程运行的实际时间。而第二次之后的调用是自第一次调用以后到现在的运行时间。（实际上是以WIN32上QueryPerformanceCounter()为基础，它比毫秒表示更为精确）
使用time.clock()更改后的程序查看一下：
import platform print('系统:',platform.system()) import time T1 = time.clock() #______假设下面是程序部分______ for i in range(100*100): pass T2 =time.clock() print('程序运行时间:%s毫秒' % ((T2 - T1)*1000)) # 程序运行时间:0.27023641716203606毫秒 使用time.perf_counter() 返回性能计数器的值（以微秒为单位,1秒=1000毫秒；1毫秒=1000微秒）作为浮点数，即具有最高可用分辨率的时钟，以测量短持续时间。它包括在睡眠期间和系统范围内流逝的时间。返回值的参考点未定义，因此只有连续调用结果之间的差异有效。
1秒 = 1000毫秒
1毫秒 = 1000微秒
1微秒 = 1000纳秒
1纳秒 = 1000皮秒...</p></div><footer class=entry-footer><span title="2022-08-08 00:51:32 +0800 +0800">August 8, 2022</span>&nbsp;·&nbsp;keae</footer><a class=entry-link aria-label="post link to Python程序计时" href=https://keae12315.github.io/blog/post/python%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%97%B6/></a></article><article class=post-entry><header class=entry-header><h2>使用搜索引擎的技巧</h2></header><div class=entry-content><p>学会使用搜索运算符 关于算术运算符的几个小技巧其实并不新鲜，很多是和搜索引擎本身一起诞生的，甚至已经成为了各个搜索引擎的一种通用标准。 不过鉴于仍然有许多人不知道这些搜索运算符，或者没有概念它们具体能做什么，所以我们先来讲一讲这些最基本的知识。
双引号”"：完全匹配。结果中必须出现与搜索文本完全相同的内容。 短横-：排除。 加号+：包含搜索。 ~ 进行同义词搜索。 site：在某个网站内搜索。 filetype：搜索对应类型的文件。 link 搜索网页中含有某链接的结果，比如搜索：link:http://baidu.com，则结果为包含百度这个链接的页面。
intitle 搜索标题内包含关键词的结果。
inurl 搜索网站地址中包含关键词的结果。
related 搜索相关网站。
index of 可以突破网站入口下载。
如何进行学术搜索 综述类关键词 overview survey review</p></div><footer class=entry-footer><span title="2022-08-08 00:50:01 +0800 +0800">August 8, 2022</span>&nbsp;·&nbsp;keae</footer><a class=entry-link aria-label="post link to 使用搜索引擎的技巧" href=https://keae12315.github.io/blog/post/%E4%BD%BF%E7%94%A8%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%8A%80%E5%B7%A7/></a></article><article class=post-entry><header class=entry-header><h2>VS Code远程连接</h2></header><div class=entry-content><p>微软针对Vs code的远程开发推出了三个插件，包括 ：
Remote-SSH：SSH 连接虚拟/实体Linux主机； Remote-Container：连接容器； Remote-WSL：连接WSL（也就是Linux子系统）。 重点服务使用Windows但具有Linux开发需求的用户。 使用Remote-SSH连接实验室服务器 这里是微软关于SSH连接的官方文档
安装Remote-SSH插件 在Extension侧边栏搜索Remote-ssh并安装
修改ssh配置文件 文件位置C:\Users\&lt;user>\.ssh\config，如果没有这个文件夹，在管理可选功能里添加 OpenSSH 客户端。
在config文件中写入以下内容
Host Labserve #填写别名 HostName 1.1.1.1 #填写实验室服务器IP/host User user #填写ssh用户名 添加ssh公钥 远程ssh连接Linux服务器时，需要借助ssh公钥登录.
生成ssh公钥
在cmd中输入ssh-keygen，一路回车键，完成后在$HOME/.ssh/目录下可以发现两个文件：id_rsa.pub和id_rsa，分别是客户端的公钥和私钥。
上传ssh公钥
登录远程服务器，创建.ssh目录和authorized_keys文件
mkdir ~/.ssh/ cd ~/.ssh/ vim authorized_keys 修改ssh配置
vim /etc/ssh/sshd_config RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile $h/.ssh/authorized_keys 保存并退出vim。
重启ssh服务 service ssh restart 通过CONNECTION侧边栏进行连接 此时，已经可以在CONNECTION侧边栏看见服务器的别名，点击进行连接。 特别的，如果没有生成ssh公钥，这一步可能会要求输入服务器密码。
问题汇总 阿里云、腾讯云等云服务器连接超时 目前VSCode的远程连接插件，默认勾选Use Local Server，也就是默认使用本地局域网络进行连接。如果你遇到阿里云等云服务器连接超时，应该取消勾选此项。...</p></div><footer class=entry-footer><span title="2022-08-08 00:39:12 +0800 +0800">August 8, 2022</span>&nbsp;·&nbsp;keae</footer><a class=entry-link aria-label="post link to VS Code远程连接" href=https://keae12315.github.io/blog/post/vscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/></a></article><article class=post-entry><header class=entry-header><h2>Docker教程</h2></header><div class=entry-content><p>本文默认环境为Linux，打包镜像以Python为例。
常用操作 查看镜像：docker images 查看所有容器：docker ps -a 查看所有容器ID：docker ps -aq 查看所有正在运行容器：docker ps 停止容器：docker stop 停止所有容器：docker stop $(docker ps -aq) 删除容器：docker rm 删除镜像：docker rmi 删除所有停止的容器：docker container prune -f 删除所有不使用的镜像：docker image prune -f -a 保存镜像：docker save > 加载镜像：docker load &lt; 注意，删除前需要先停止容器。
安装 官方安装教程
Ubuntu Windows MacOS 配置 官方原文过长，摘取了常用的两个步骤。
配置root用户 Docker绑定到Unix socket，但它需要sudo权限。如果不想每次都加sudo命令，创建一个名为Docker的Unix组.
# 创建docker组。 sudo groupadd docker # 将用户添加到docker组。 sudo usermod -aG docker $USER # 激活对组的更改 newgrp docker 配置开机启动 注意，在 Debian 和 Ubuntu 上，Docker 服务被配置为默认启动。要在其他发行版的引导中自动启动 Docker 和 Containerd，请使用以下命令:...</p></div><footer class=entry-footer><span title="2022-08-08 00:29:27 +0800 +0800">August 8, 2022</span>&nbsp;·&nbsp;keae</footer><a class=entry-link aria-label="post link to Docker教程" href=https://keae12315.github.io/blog/post/docker%E6%95%99%E7%A8%8B/></a></article><article class=post-entry><header class=entry-header><h2>网络模型简述</h2></header><div class=entry-content><p>OSI七层网络模型
应用层 与其它计算机进行通讯的一个应用，它是对应应用程序的通信服务的。例如，一个没有通信功能的字处理程序就不能执行通信的代码，从事字处理工作的程序员也不关心OSI的第7层。但是，如果添加了一个传输文件的选项，那么字处理器的程序就需要实现OSI的第7层。示例：TELNET，HTTP，FTP，NFS，SMTP等。 表示层 这一层的主要功能是定义数据格式及加密。例如，FTP允许你选择以二进制或ASCII格式传输。如果选择二进制，那么发送方和接收方不改变文件的内容。如果选择ASCII格式，发送方将把文本从发送方的字符集转换成标准的ASCII后发送数据。在接收方将标准的ASCII转换成接收方计算机的字符集。示例：加密，ASCII等。 会话层 它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的，在某些情况下，如果表示层收到了所有的数据，则用数据代表表示层。示例：RPC，SQL等。 传输层 这层的功能包括是选择差错恢复协议还是无差错恢复协议，及在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。示例：TCP，UDP，SPX。 网络层 这层对端到端的包传输进行定义，它定义了能够标识所有结点的逻辑地址，还定义了路由实现的方式和学习的方式。为了适应最大传输单元长度小于包长度的传输介质，网络层还定义了如何将一个包分解成更小的包的分段方法。示例：IP，IPX等。 数据链路层 它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI等。 物理层 OSI的物理层规范是有关传输介质的特性，这些规范通常也参考了其他组织制定的标准。连接头、帧、帧的使用、电流、编码及光调制等都属于各种物理层规范中的内容。物理层常用多个规范完成对所有细节的定义。示例：Rj45，802.3等。 协议、TCP 和 UDP 在了解 TCP(Transmission Control Protocol 即传输控制协议) 和 UDP(User Datagram Protocol 即用户数据包协议) 之前，我们先要知道一个名词，即协议。它到底是什么？它其实就是一套约定成俗的规则。就像开会的时候，我们达成了一些共识，先开发那个接口，项目什么时候上线等等。
可以毫不夸张地说计算机网络的构建与发展，奠基石就是各种网络协议。它们定义了信息通讯的方式，以及如何收发信息等，比如：
IP 协议负责将多个包交换网络连接起来，并管理通讯 IP 源地址和目标地址的协议 TCP 和 UDP 协议则是位于应用层和 IP 层之间，负责它们之间信息传输的重要协议</p></div><footer class=entry-footer><span title="2022-08-07 03:12:48 +0800 +0800">August 7, 2022</span>&nbsp;·&nbsp;keae</footer><a class=entry-link aria-label="post link to 网络模型简述" href=https://keae12315.github.io/blog/post/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%AE%80%E8%BF%B0/></a></article><article class=post-entry><header class=entry-header><h2>内存分配算法</h2></header><div class=entry-content><p>First Fit 该算法从空闲分区链首开始查找，直至找到一个能满足其大小要求的空闲分区为止。然后再按照作业的大小，从该分区中划出一块内存分配给请求者，余下的空闲分区仍留在空闲分区链中。
特点: 该算法倾向于使用内存中低地址部分的空闲区，在高地址部分的空闲区很少被利用，从而保留了高地址部分的大空闲区。显然为以后到达的大作业分配大的内存空间创造了条件。 缺点: 低地址部分不断被划分，留下许多难以利用、很小的空闲区，而每次查找又都从低地址部分开始，会增加查找的开销。 Next Fit 该算法是由首次适应算法演变而成的。在为进程分配内存空间时，不再每次从链首开始查找，直至找到一个能满足要求的空闲分区，并从中划出一块来分给作业。
特点: 使内存中的空闲分区分布的更为均匀，减少了查找时的系统开销。 缺点: 缺乏大的空闲分区，从而导致不能装入大型作业。 Best Fit 该算法总是把既能满足要求，又是最小的空闲分区分配给作业。为了加速查找，该算法要求将所有的空闲区按其大小排序后，以递增顺序形成一个空白链。这样每次找到的第一个满足要求的空闲区，必然是最优的。孤立地看，该算法似乎是最优的，但事实上并不一定。因为每次分配后剩余的空间一定是最小的，在存储器中将留下许多难以利用的小空闲区。同时每次分配后必须重新排序，这也带来了一定的开销。
特点: 每次分配给文件的都是最合适该文件大小的分区。 缺点: 内存中留下许多难以利用的小的空闲区。 Worst Fit 该算法按大小递减的顺序形成空闲区链，分配时直接从空闲区链的第一个空闲区中分配（不能满足需要则不分配）。很显然，如果第一个空闲分区不能满足，那么再没有空闲分区能满足需要。这种分配方法初看起来不太合理，但它也有很强的直观吸引力: 在大空闲区中放入程序后，剩下的空闲区常常也很大，于是还能装下一个较大的新程序。
最坏适应算法与最佳适应算法的排序正好相反，它的队列指针总是指向最大的空闲区，在进行分配时，总是从最大的空闲 区开始查寻。 该算法克服了最佳适应算法留下的许多小的碎片的不足，但保留大的空闲区的可能性减小了，而且空闲区回收也和最佳适 应算法一样复杂。
特点: 给文件分配分区后剩下的空闲区不至于太小，产生碎片的几率最小，对中小型文件分配分区操作有利。 缺点: 使存储器中缺乏大的空闲区，对大型文件的分区分配不利。 buddy system 伙伴分配算法将总内存设为2的n次幂，并将内存按照2的n次幂的格式进行分发。
需要分配内存的时：核心就是分配出不小于所需的最小2次幂大小的内存(如果需要25，就分配32；如果需要63，就分配64)，具体分配时，如果有符合的内存块，直接分配即可；如果当前的空闲块没有满足要求的，就将大块进行二等分，继续重复分配过程
需要释放内存时：首先将该内存块释放，然后看其相邻的块(可以进行合并的相邻块，即在分配时由一个内存块分成的两个等大内存块)是否释放，如果相邻块没有释放，则结束即可；如果相邻块释放，则将两个块合并，重复释放过程，对合并后的块进行释放。对相邻块做一个更容易实现的解释：相邻块不仅地址相邻，且二者中的低地址块的地址必须为2的整数幂。
优点是快速搜索合并（O(logN)时间复杂度）以及低外部碎片（最佳适配best-fit） 缺点是内部碎片，因为按2的幂划分块，如果碰上65单位大小，那么必须划分128单位大小的块。实际上存储结点信息也会占用一小部分内存，但该算法总体上来看性能还是比较优越的。 Slab lab以内存池为思想，解决内部碎片问题，专门解决小内存问题。提供一种可分配任意大小的内存分配机制。
slab分配器是基于对象进行管理，将相同类型的对象归为一类，每当要申请这样一个对象时，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免内部碎片。slab分配器并不丢弃已经分配的对象，而是释放并把它们保存在内存中。slab分配对象时，会使用最近释放的对象的内存块，因此其驻留在cpu高速缓存中的概率会大大提高。
slab算法在buddy-system分配大内存的基础上，对小内存区域进行了有效的管理。可以解决内部碎片问题，提供一种可分配任意大小的内存分配机制，slab 分配器还支持通用对象的初始化，从而避免了为同一目的而对一个对象重复进行初始化。slab算法最大的缺点就是复杂，包括队列管理较为复杂、缓冲区管理较为复杂，以及实现起来非常复杂。
参考文献
https://blog.csdn.net/liying_1234/article/details/52053183#:~:text=%E5%9B%9B%E3%80%81%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95,%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E8%83%BD%E6%BB%A1%E8%B6%B3%E9%9C%80%E8%A6%81%E3%80%82
https://blog.csdn.net/dingdingdodo/article/details/100624125</p></div><footer class=entry-footer><span title="2022-08-07 03:12:22 +0800 +0800">August 7, 2022</span>&nbsp;·&nbsp;keae</footer><a class=entry-link aria-label="post link to 内存分配算法" href=https://keae12315.github.io/blog/post/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://keae12315.github.io/blog/page/2/>Next »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://keae12315.github.io/blog/>KEAE的编程笔记</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z" /></svg></a><script>let menu=document.getElementById('menu')
if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>